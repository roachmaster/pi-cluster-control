#ifndef {{HEADER_GUARD}}
#define {{HEADER_GUARD}}

/**
 * @file {{HEADER_FILENAME}}
 * @brief {{DESCRIPTION}}
 */

{{#INCLUDES}}
#include {{{.}}}
{{/INCLUDES}}

namespace {{NAMESPACE}} {

    using {{ALIAS_EXECUTION_LABEL_TYPE}} = {{ALIAS_DATA_TYPE}};

    /**
     * @brief CRTP base class for {{CLASS_NAME}}-like behavior.
     *
     * Derived classes must implement:
     *   - {{METHOD_EXECUTE_RETURN_TYPE}} {{METHOD_EXECUTE_IMPL}}();
     *   - {{ALIAS_EXECUTION_LABEL_TYPE}} {{METHOD_LABEL_IMPL}}() const;
     */
    template<typename Derived>
    class {{CLASS_NAME}} {
    public:
        {{METHOD_EXECUTE_RETURN_TYPE}} {{METHOD_EXECUTE}}() {
            return static_cast<Derived*>(this)->{{METHOD_EXECUTE_IMPL}}();
        }

        {{ALIAS_EXECUTION_LABEL_TYPE}} {{METHOD_LABEL}}() const {
            return static_cast<const Derived*>(this)->{{METHOD_LABEL_IMPL}}();
        }

    protected:
        {{CLASS_NAME}}() = default;
        {{CLASS_NAME}}(const {{CLASS_NAME}}&) = delete;
        {{CLASS_NAME}}& operator=(const {{CLASS_NAME}}&) = delete;
    };

} // namespace {{NAMESPACE}}

#endif // {{HEADER_GUARD}}