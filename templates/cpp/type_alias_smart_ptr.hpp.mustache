#ifndef {{HEADER_GUARD}}
#define {{HEADER_GUARD}}

{{#includes}}
#include {{{.}}}
{{/includes}}

namespace {{NAMESPACE}} {

    /**
     * @brief Type-safe smart pointer for managing {{BASE_TYPE}}-derived instances.
     *
     * This alias wraps std::unique_ptr<T> and enforces that T is a valid {{BASE_TYPE}} type.
     */
    template<typename T>
    struct {{ALIAS_NAME}}_helper {
        static_assert({{TRAIT_NAME}}<T>, "{{ALIAS_NAME}} must wrap a {{BASE_TYPE}}-derived type.");
        using type = std::unique_ptr<T>;
    };

    template<typename T>
    using {{ALIAS_NAME}} = typename {{ALIAS_NAME}}_helper<T>::type;

} // namespace {{NAMESPACE}}

#endif // {{HEADER_GUARD}}