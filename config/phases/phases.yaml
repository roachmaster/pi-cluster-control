PHASES:
  - PHASE: 0
    NAME: The Core
    GOAL: Establish a type-safe, lambda-driven declarative system for Forgeables.
    INCLUDES:
      - "forge-core: definitions, registry, resolver, provider"
      - "forge-engine: DAG executor for Forgeables"
      - "forge-config: YAML/JSON ingestion adapter"
      - "forge-api: interfaces to inject Forgeables and start processing"
    NOTES: This is the current operational baseline.

  - PHASE: 1
    NAME: Memory-Mapped Registry
    GOAL: Use memory-mapped .img files to enable near-instant Forge registry loading and zero-latency Forgeable lookup.
    INNOVATIONS:
      - "Binary layouts for Forges"
      - "Offset-based lookup instead of virtual functions"
      - "mmap-based paging of Forge registry data"

  - PHASE: 2
    NAME: Local Clustering
    GOAL: Deploy Forge executables as microservices on a single machine or LAN.
    CAPABILITIES:
      - "Each service handles a Forge domain (e.g., goal, bdd, config)"
      - "Each has its own registry and persistence"
      - "Communication via IPC or TCP"

  - PHASE: 3
    NAME: Distributed Memory + Persistence
    GOAL: Build a distributed Forge fabric with global awareness and local consistency.
    FEATURES:
      - "Memory-mapped registries per node"
      - "Sharded persistence (SQLite, ForgeDB)"
      - "Routing Forgeables by ID, hash, or DAG node"

  - PHASE: 4
    NAME: Fault Tolerance & Coordination
    GOAL: Enable self-healing orchestration across a Forge cluster.
    ADVANCEMENTS:
      - "Dead-forge detection"
      - "Task rebalancing and fallback"
      - "Cluster-wide heartbeat and policy engine"

  - PHASE: 5
    NAME: Forge Intelligence
    GOAL: Integrate LLMs (Ollama) as execution agents and generators inside Forge.
    VISION:
      - "Autogenerated Forgeables, YAML specs, and DSLs"
      - "Self-healing test failures"
      - "Prompt cache DAGs for scenario memory and intent"